import { Injectable, Logger } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { createClient, RedisClientType } from 'redis';
import { Notification, NotificationDocument } from '../schemas/notification.schema';
import { User, UserDocument } from '../schemas/user.schema';
import { NotificationGateway } from '../gateways/notification.gateway';
import { v4 as uuidv4 } from 'uuid';

@Injectable()
export class NotificationWorker {
  private readonly logger = new Logger(NotificationWorker.name);
  private redis: RedisClientType;

  constructor(
    @InjectModel(Notification.name) private notificationModel: Model<NotificationDocument>,
    @InjectModel(User.name) private userModel: Model<UserDocument>,
    private readonly notificationGateway: NotificationGateway,
  ) {
    this.initRedis();
  }

  private async initRedis() {
    this.redis = createClient({
      socket: {
        host: process.env.REDIS_HOST || 'localhost',
        port: parseInt(process.env.REDIS_PORT || '6379'),
      },
    });

    this.redis.on('error', (err) => {
      this.logger.error('Redis Client Error', err);
    });

    await this.redis.connect();
    this.logger.log('Redis connected for Notification Worker');
  }

  private getTimeLeftText(from: Date, to: Date): string {
    const msLeft = to.getTime() - from.getTime();
    const minutesLeft = Math.floor(msLeft / (60 * 1000));
    const hoursLeft = Math.floor(minutesLeft / 60);
    const daysLeft = Math.floor(hoursLeft / 24);

    if (daysLeft > 0) return `${daysLeft} ng√†y`;
    if (hoursLeft > 0) return `${hoursLeft} gi·ªù`;
    return `${minutesLeft} ph√∫t`;
  }

  // Check for scheduled notifications every 10 seconds
  @Cron('*/10 * * * * *')
  async handleScheduledNotifications() {
    const now = Date.now();
    const userKeys = await this.redis.keys('notifications:*');

    for (const key of userKeys) {
      const dueNotifs = await this.redis.zRangeByScore(key, 0, now);

      for (const raw of dueNotifs) {
        const notif = JSON.parse(raw);

        try {
          // Send WebSocket notification
          this.notificationGateway.sendToUser(notif.userId, notif);

          // Update notification as sent in database
          await this.notificationModel.findOneAndUpdate(
            { notificationId: notif.notificationId },
            { sent: true }
          );

          this.logger.log(`Scheduled notification sent to user: ${notif.userId}`);
        } catch (error) {
          this.logger.error('Failed to send scheduled notification:', error);
        }

        // Remove from Redis
        await this.redis.zRem(key, raw);
      }
    }
  }

  // Send a random notification every 30 seconds for testing
  @Cron('*/30 * * * * *')
  async sendRandomNotification() {
    try {
      const users = await this.userModel.find().limit(3).exec();
      
      if (users.length === 0) {
        this.logger.warn('No users found for random notification');
        return;
      }

      const randomUser = users[Math.floor(Math.random() * users.length)];
      const notificationMessages = [
        'üîî [TEST] Th√¥ng b√°o ng·∫´u nhi√™n - Ki·ªÉm tra h·ªá th·ªëng notification',
        'üìß [TEST] Nh·∫Øc nh·ªü: B·∫°n c√≥ email m·ªõi c·∫ßn xem',
        'üéâ [TEST] Ch√∫c m·ª´ng! B·∫°n ƒë√£ online th√†nh c√¥ng',
        '‚ö° [TEST] H·ªá th·ªëng ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t v·ªõi t√≠nh nƒÉng m·ªõi',
        'üöÄ [TEST] Th√¥ng b√°o t·ª± ƒë·ªông - H·ªá th·ªëng ho·∫°t ƒë·ªông t·ªët',
        'üí° [TEST] G·ª£i √Ω: H√£y th·ª≠ t√≠nh nƒÉng chat real-time',
        'üî• [TEST] Trending: B·∫°n ƒëang online c√πng v·ªõi nh·ªØng ng∆∞·ªùi kh√°c',
      ];

      const randomMessage = notificationMessages[Math.floor(Math.random() * notificationMessages.length)];

              const notification = new this.notificationModel({
          notificationId: uuidv4(),
          userId: randomUser.userId,
          title: 'üîî [AUTO] Th√¥ng b√°o t·ª± ƒë·ªông',
          content: randomMessage,
          type: 'system',
          isRead: false,
          sent: true,
          scheduledTime: new Date(),
          metadata: {
            autoGenerated: true,
            testNotification: true,
          },
        });

      await notification.save();

      // Send real-time notification
      this.notificationGateway.sendToUser(randomUser.userId, {
        notificationId: notification.notificationId,
        userId: randomUser.userId,
        title: notification.title,
        content: notification.content,
        type: notification.type,
        createdAt: notification.createdAt,
      });

      this.logger.log(`Random notification sent to user: ${randomUser.userId}`);
    } catch (error) {
      this.logger.error('Error sending random notification:', error);
    }
  }

  // Broadcast system notification every 2 minutes
  @Cron('0 */2 * * * *')
  async sendSystemBroadcast() {
    try {
      const users = await this.userModel.find().exec();
      const systemMessages = [
        '‚úÖ [BROADCAST] H·ªá th·ªëng ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng - T·∫•t c·∫£ t√≠nh nƒÉng ƒëang online',
        'üåü [BROADCAST] Ch√∫c b·∫°n m·ªôt ng√†y l√†m vi·ªác hi·ªáu qu·∫£!',
        'üôè [BROADCAST] C·∫£m ∆°n b·∫°n ƒë√£ test h·ªá th·ªëng notification c·ªßa ch√∫ng t√¥i',
        'üí¨ [BROADCAST] H·ªá th·ªëng chat real-time ƒëang ho·∫°t ƒë·ªông t·ªët',
        'üîî [BROADCAST] Th√¥ng b√°o h·ªá th·ªëng: T·∫•t c·∫£ user ƒëang ƒë∆∞·ª£c k·∫øt n·ªëi',
      ];

      const randomMessage = systemMessages[Math.floor(Math.random() * systemMessages.length)];

      for (const user of users) {
        const notification = new this.notificationModel({
          notificationId: uuidv4(),
          userId: user.userId,
          title: 'üì¢ [SYSTEM] Th√¥ng b√°o h·ªá th·ªëng',
          content: randomMessage,
          type: 'broadcast',
          isRead: false,
          sent: true,
          scheduledTime: new Date(),
          metadata: {
            broadcastType: 'system',
            allUsers: true,
          },
        });

        await notification.save();
      }

      // Broadcast to all users
      this.notificationGateway.broadcastToAll({
        title: 'üì¢ [SYSTEM] Th√¥ng b√°o h·ªá th·ªëng',
        content: randomMessage,
        type: 'broadcast',
        createdAt: new Date(),
        metadata: {
          broadcastType: 'system',
          allUsers: true,
        },
      });

      this.logger.log(`System broadcast sent to ${users.length} users`);
    } catch (error) {
      this.logger.error('Error sending system broadcast:', error);
    }
  }

  // Schedule a notification for later delivery
  async scheduleNotification(userId: string, notification: any, scheduledTime: Date) {
    try {
      const key = `notifications:${userId}`;
      const score = scheduledTime.getTime();
      const value = JSON.stringify(notification);

      await this.redis.zAdd(key, { score, value });
      this.logger.log(`Notification scheduled for user: ${userId} at ${scheduledTime}`);
    } catch (error) {
      this.logger.error('Error scheduling notification:', error);
    }
  }

  // Create and send immediate notification
  async createAndSendNotification(userId: string, title: string, content: string, type: string = 'system') {
    try {
      const notification = new this.notificationModel({
        notificationId: uuidv4(),
        userId,
        title,
        content,
        type,
        isRead: false,
        sent: true,
        scheduledTime: new Date(),
      });

      await notification.save();

      // Send real-time notification
      this.notificationGateway.sendToUser(userId, {
        notificationId: notification.notificationId,
        userId,
        title,
        content,
        type,
        createdAt: notification.createdAt,
      });

      this.logger.log(`Immediate notification sent to user: ${userId}`);
      return notification;
    } catch (error) {
      this.logger.error('Error creating and sending notification:', error);
      throw error;
    }
  }
} 